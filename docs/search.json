[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "",
    "text": "Quarto é um sistema de produção de publicações técnicas e científicas que incorpora ferramentas de formatação de texto com códigos de programação para produção de gráficos e tabelas. É o sucessor do R markdown e segue a linha de outros notebooks reativos, como o Jupyter Notebook. É um sistema de código aberto cujos principais destques são permitir a utilização de diversas linguagens de programação (Python, R, Julia e Observable) e a exportação para diversos formatos de publicação através da utilização do Pandoc.\nAs suas funcionalidades relativas ao processamento de dados espaciais e tabulares com linguagens de programação e produção de documentos em .pdf ou .doc já são interessantes por facilitar a padronização da análise e publicação de resultados. Mas são sua integração com o Observable e capacidade de produção de documentos html que oferecem as maiores possibilidades de enriquecimento da publicação com conteúdo dinâmico e interativo.\nElementos interativos como listas de seleção, tabelas, e gráficos, etc, produzidos nas linguagens Python, R ou Julia possuem recursos limitados de interatividade em publicações online, necessitando de frameworks como o Dash ou o Shiny para poderem apresentar comportamento realmente dinâmico. Esses frameworks exigem a configuração do servidor de hospedagem com os interpretadores e bibliotecas e também de tempo de processamento para atender requisições dos usuários, dificultando a utilização dessas capacidades na publicação de resultados de pesquisas. O Observable, porém, é um JavaScript melhorado que é interpretado diretamente pelo navegador do usuário, dispensando a utilização do servidor no processamento dos dados. Essa característica, associada à utilização de geoserviços do IBGE, permite desde a publicação enriquecida com conteúdo interativo até a produção de dashboards complexos com dados de diversas fontes sem a necessidade de gastos com servidor e apoio institucional."
  },
  {
    "objectID": "index.html#e-eis-a-parte-interativa",
    "href": "index.html#e-eis-a-parte-interativa",
    "title": "QuartoEstudo",
    "section": "e eis a parte interativa!",
    "text": "e eis a parte interativa!\n\n\nCode\nbertin = require(\"bertin\")\n\njsonURL = \"https://geoservicos.ibge.gov.br/geoserver/CGEO/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=CGEO%3APARBR2018_BATER_MD&maxFeatures=600000&outputFormat=application%2Fjson\"\n\nbater = d3.json(jsonURL)\n\nviewof selmun = Inputs.select(\n  bater.features.map((d) => d.properties.municipio),\n  {\n    sort: true,\n    unique: true,\n    label: \"Município\"\n  }\n)\n\nmunicipioArray = bater.features.filter((d) => d.properties.municipio == selmun)\n\nmunicipio = ({\n  \"type\":\"FeatureCollection\",\n  \"features\":municipioArray  \n})\n\nsimplemap = bertin.draw({\n  params: { background: \"#bde1f0\", margin: 10 },\n  layers: [{\n      type: \"layer\",\n      geojson: municipio,\n      fill: \"#ff0000\",\n      stroke: \"#ff0000\",\n      strokeWidth: 1,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"tiles\",\n      opacity: 1,\n      style: \"openstreetmap\",\n    }\n  ]\n})"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html#processamento-dos-dados-através-do-r",
    "href": "index.html#processamento-dos-dados-através-do-r",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "Processamento dos dados através do R",
    "text": "Processamento dos dados através do R\n\nDados\nCarrega a tabela do Excel com os dados.\n\n\nCode\nplanilha <- read_excel(\"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/AtlasNacional/Alertas/AlertasCemaden2012-2021.xlsx\")\n\n# datatable(planilha)\n\n\n\n\nBibliotecas\nCarrega as bibliotecas necessárias. São muitas, nesse caso.\n\n\nCode\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(writexl)\nlibrary(sf)\nlibrary(DT)\nlibrary(clock)\nlibrary(ggthemes)\nlibrary(showtext)\nlibrary(RColorBrewer)\n\n\n\n\nAgregação\nProduz a tabela de total de alertas por município.\n\n\nCode\nTot_Mun <- planilha %>%\n  mutate(Mun = str_to_upper(`Município`)) %>%\n  group_by(`Código IBGE`, Mun, `Evento`) %>%\n  summarise(Tot_Event = n()) %>%\n  mutate(Evento = ifelse(Evento == \"Geo/Hidro\", \"Hidrogeo\", Evento)) %>%\n  pivot_wider(names_from = Evento, values_from = Tot_Event, values_fill = 0) %>%\n  mutate(tot_geo = Geo + Hidrogeo, tot_hidro = Hidro + Hidrogeo) %>%\n  select(`Código IBGE`, Mun, tot_geo, tot_hidro)\n\ndatatable(Tot_Mun, colnames = c(\"Geocódigo\", \"Município\", \"Alertas Geológicos\", \"Alertas Hidrológicos\"))\n\n\n\n\n\n\n\n\n\nProcessamento\nCalcula as médias mensais por grande região e país e junta tudo numa mesma tabela, Med_Geral.\n\n\nCode\nMed_GdReg_data <- planilha %>%\n  mutate(dataref = date_group(as.Date(planilha$Data), \"month\"),\n         mes = factor(date_format(dataref, format = \"%m\"), \n                      labels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")),\n         GdReg = factor(as.numeric(substr(`Código IBGE`, 1, 1)), labels = c(\"N\", \"NE\", \"SE\", \"S\", \"CO\")),\n         geologico = ifelse(Evento %in% c(\"Geo\", \"Geo/Hidro\"), 1, 0),\n         hidrologico = ifelse(Evento %in% c(\"Hidro\", \"Geo/Hidro\"), 1, 0)) %>%\n  group_by(GdReg, mes, dataref) %>%\n  summarise(Tot_Event = n(), Tot_geo = sum(geologico), Tot_hidro = sum(hidrologico)) %>%\n  ungroup() %>%\n  group_by(GdReg, mes) %>%\n  summarise(Media_geo = mean(Tot_geo), Media_hidro = mean(Tot_hidro), Media_Event = mean(Tot_Event)) %>%\n  # manobra esquisita para arrumar a tabela, rever esse código adiante de pivotagem\n  pivot_longer(cols = starts_with(\"Media_\"), names_to = \"Tipo\", values_to = \"Media\") %>%\n  pivot_wider(names_from = c(\"mes\", \"Tipo\"), values_from = Media, values_fill = 0) %>%\n  pivot_longer(cols = !GdReg, names_to = c(\"mes\", \"Tipo\"), names_pattern = \"(.*)_Media_(.*)\", values_to = \"Media\") %>%\n  # até aqui.\n  ungroup() %>%\n  group_by(Tipo, mes) %>%\n  mutate(mes = factor(mes, levels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")))\n\n\nMed_Pais_geral <- Med_GdReg_data %>%\n  group_by(Tipo, mes) %>%\n  summarise(Media = sum(Media)) %>%\n  mutate(GdReg = \"Brasil\") %>%\n  select(GdReg, mes, Tipo, Media)\n\nMed_Geral <- Med_GdReg_data %>%\n  bind_rows(Med_Pais_geral) %>%\n  mutate(GdReg = factor(GdReg, levels = c(\"Brasil\", \"N\", \"NE\", \"SE\", \"S\", \"CO\")))\n\nMed_Geral %>% \n  filter(Tipo == \"Event\") %>%\n  mutate(Media = round(Media, 2)) %>%\n  pivot_wider(id_cols = GdReg, names_from = mes, values_from = Media) %>%\n  datatable()"
  },
  {
    "objectID": "index.html#produção-dos-gráficos-estáticos",
    "href": "index.html#produção-dos-gráficos-estáticos",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "Produção dos gráficos estáticos",
    "text": "Produção dos gráficos estáticos\n\nTema\nCarrega configurações de tema para os gráficos, desenvolvido pro Atlas Nacional Digital.\n\n\nCode\nshowtext_auto()\nshowtext_opts(dpi = 300)\nfont_add(family = \"univers\", regular = \"C:/Windows/Fonts/univer.TTF\")\n\ntheme_set(\n  theme_igray() + \n    theme(plot.title = element_text(family = \"univers\", face = \"bold\", size = 11, hjust = 0.5, vjust = 0.5, lineheight = 1.1, margin = margin(12, 0, 12, 0)),\n          legend.position = \"bottom\",\n          legend.title = element_blank(),\n          legend.background = element_rect(fill = \"white\"),\n          legend.text = element_text(family = \"univers\", face = \"plain\", size = 9, margin = margin(0, 15, 0, 5)),\n          legend.key.width = unit(1.5, \"cm\"),\n          plot.background = element_rect(fill = \"#d0cece\"),\n          plot.margin = margin(t = 0, r = 40, b = 0, l = 10 ),\n          axis.title = element_text(family = \"univers\", face = \"plain\", size = 9),\n          axis.text = element_text(family = \"univers\", face = \"plain\", size = 7)))\n\ncores <- c(\"#000000\", brewer.pal(5, \"Set1\"))\nnames(cores) <- c(\"Brasil\", levels(Med_GdReg_data$GdReg))\ncolScale <- scale_color_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = cores)\nlineScale <- scale_linetype_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = c(2, 1, 1, 1, 1, 1))\n\n\n\n\nAlertas Hidrológicos\n\n\nCode\ngraf_hidro <- Med_Geral %>%\n  filter(Tipo == \"hidro\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco hidrológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_hidro\n\n\n\n\n\nFigure 1: Hidrológico\n\n\n\n\n\n\nAlertas Geológicos\n\n\nCode\ngraf_geo <- Med_Geral %>%\n  filter(Tipo == \"geo\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco geológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_geo\n\n\n\n\n\nFigure 2: Geológico\n\n\n\n\n\n\nAlertas\nAinda tenho que ver como definir o tamanho individual das figuras. Por enquanto tá definido globalmente, no início do documento, e em polegadas, eca.\n\n\nCode\ngraf_geral <- Med_Geral %>%\n  filter(Tipo == \"Event\") %>%\n  arrange(GdReg) %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Média mensal de alertas de risco geohidrológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40)) +\n  facet_wrap(vars(GdReg), nrow = 1)\n\ngraf_geral\n\n\n\n\n\nFigure 3: Geral\n\n\n\n\nDá pra referenciar as imagens no texto, Figure 1, Figure 2 e Figure 3."
  },
  {
    "objectID": "index.html#interatividade",
    "href": "index.html#interatividade",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "Interatividade",
    "text": "Interatividade\nExistem muitas possibilidades de interatividade, em tabelas, gráficos e mapas. Teste primeiramente a produção de mapas, que me parece mais complexa. Para obter a interatividade rodando direto do navegador, deve-se utilizar o Observable. Infelizmente o proxy do IBGE bloqueia! Vou pedir pra DI liberar depois.\n\nBibliotecas\nCarrega a biblioteca bertin.js para a produção de mapas\n\n\nCode\nbertin = require(\"bertin@1\");\n\n\n\n\n\n\n\n\n\nFonte de dados e filtragem REVISAR\nCarrega o JSON servido pelo serviço WFS do geoserver do IBGE. Ver aqui a lista de serviços disponibilizada pelo IBGE. Tem bastante coisa! No caso das BATERs, elas já vêm com os variáveis da publicação, além da geometria. A grande vantagem de usar o serviço wfs é não precisar manter as camadas espaciais que forem utilizadas na parte interativa no repositório do site, economizando muito espaço de armazenamento. As feições são filtradas segundo o município selecionado. O correto na verdade é aplicar o filtro antes de requisitar a camada wfs pra diminuir o tráfego de dados. Do jeito que está demora para carregar inicialmente o mapa, tem todo o tempo de recebimento da camada completa wfs do IBGE. Depois eu vejo como fazer.\n\n\nCode\nurlWFS = \"https://geoservicos.ibge.gov.br/geoserver/ows\";\n\nlistaUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  PropertyName: \"cd_uf,nm_uf\",\n  outputFormat: \"application/json\"\n});\n\ngeo_uf = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  cql_filter: `nm_uf='${selNomUF}'`,\n  outputFormat: \"application/json\"\n});\n\nMunicUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_Municipios_mapeados\",\n  cql_filter: `uf='${selUF}'`,\n  outputFormat: \"application/json\"\n});\n\nbater = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_BATER_MD\",\n  cql_filter: `geo_mun='${selCdMunic}'`,\n  outputFormat: \"application/json\"\n});\n\nselUF = stripAccents(selNomUF);\n\nselCdMunic = MunicUF.data.features.filter((d) => d.properties.nommunic === selNomMunic)[0].properties.codmunic;\n\nselMunicArray = MunicUF.data.features.filter((d) => d.properties.nommunic == selNomMunic);\n\nselMunic = ({\n  \"type\":\"FeatureCollection\",\n  \"features\":selMunicArray  \n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput\nAqui é criado a caixinha de seleção do município. O ideal é fazer um de UF antes pra reduzir a lista resultante. Depois eu faço, na camada WFS das BATERs não tem a sigla da UF, só o geocódigo, mais difícil de escolher a UF né. Só botar uma tabelinha com isso e fazer o join que resolve.\n\n\nCode\nviewof selNomUF = Inputs.select(\n    listaUF.data.features.map((d) => d.properties.nm_uf), \n    {\n        label: \"Unidade da Federação\"\n    }\n);\n\nviewof selNomMunic = Inputs.select(\n    MunicUF.data.features.map((d) => d.properties.nommunic),\n    {\n        label: \"Município\"\n    }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nmapauf = bertin.draw({\n  params: { background: \"#bde1f0\", margin: 10 },\n  layers: [{\n      type: \"layer\",\n      geojson: selMunic,\n      fill: \"#000000\",      \n      fillOpacity: 0.8,\n      stroke: \"#000000\",\n      strokeWidth: 2,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: MunicUF.data,\n      fill: \"#ff0000\",\n      fillOpacity: 0.6,\n      stroke: \"#ff0000\",\n      strokeWidth: 1,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: geo_uf.data,\n      fill: \"#999999\",      \n      fillOpacity: 0.25,\n      stroke: \"#777777\",\n      strokeWidth: 2,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"tiles\",\n      opacity: 1,\n      style: \"openstreetmap\",\n    }\n  ]\n});\n\nmapamunic = bertin.draw({\n  params: { background: \"#bde1f0\", margin: 10 },\n  layers: [{\n      type: \"layer\",\n      geojson: bater.data,\n      fill: \"#ff0000\",\n      fillOpacity: 0.6,\n      stroke: \"#ff0000\",\n      strokeWidth: 1,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: selMunic,\n      fill: \"#999999\",      \n      fillOpacity: 0.25,\n      stroke: \"#777777\",\n      strokeWidth: 2,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"tiles\",\n      opacity: 1,\n      style: \"openstreetmap\",\n    }\n  ]\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapa\nAqui produz o mapa com as BATERs do município selecionado. A biblioteca bertin é mais pra produzir cartogramas, não dá pra “passear” pelo mapa. Mas pode-se fazer, por exemplo, janelinhas pop up com os dados da BATER que aparecem ao clicar na mesma. Existem outras bibliotecas para trabalhar com mapas, a plot que é parecida com a bertin, e algumas de mapas mesmo, openlayer, leaflet e mapbox. Devo utilizar no final a a openlayer ou a leaflet.\nAlém de mapas, dá pra produzir as tabelas interativas (a pessoa pode filtrar por qualquer campo, por exemplo, e ordenar por qualquer coluna) e gráficos também. E tudo isso rodando no navegador, sem precisar de um servidor com interpretador de R ou Python instalados, com as bibliotecas como Shiny ou Dash nas versões certas e dispor de tempo de processador para processar as ações de todos os usuários simultâneos… O servidor só precisa servir o site, e nada mais.\n\n\nTabelas Observable.js\n\n\nCode\nasync function wfsRequest(\n  url,\n  operation = \"GetCapabilities\",\n  extraParameters = {}\n) {\n  const queryParameters = new URLSearchParams({\n    request: operation,\n    service: \"WFS\",\n    ...extraParameters\n  }).toString();\n\n  console.log(queryParameters);\n\n  const response = await fetch(`${url}?${queryParameters}`);\n  const responseFormat = response.headers.get(\"Content-Type\");\n\n  // If the WFS server returns Content-Type header containing \"json\" it will read the data as json, otherwise as text.\n  const data = responseFormat.includes(\"json\")\n    ? await response.json()\n    : await response.text();\n\n  return {\n    data: data,\n    status: response.status\n  };\n};\n\nfunction stripAccents(str) {\n    var reAccents = /[àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ]/g;\n    var replacements = 'aaaaaceeeeiiiinooooouuuuyyAAAAACEEEEIIIINOOOOOUUUUY';\n    return str.replace(reAccents, function (match) {\n        return replacements[reAccents.source.indexOf(match)];\n    });\n};"
  },
  {
    "objectID": "index.html#exemplos-de-funcionalidades",
    "href": "index.html#exemplos-de-funcionalidades",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "Exemplos de funcionalidades",
    "text": "Exemplos de funcionalidades\nPara avaliar algumas funcionalidades de maior relevância, foram utilizados os dados de Alertas de riscos de desastres emitidos pelo CEMADEN compilados para o Atlas Nacional Digital do Brasil - 2022.\n\nDados e Bibliotecas\nCarrega a tabela com os dados e as bibliotecas utilizadas.\n\n\nCode\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(writexl)\nlibrary(sf)\nlibrary(DT)\nlibrary(clock)\nlibrary(ggthemes)\nlibrary(showtext)\nlibrary(RColorBrewer)\nlibrary(knitr)\n\nplanilha <- read_excel(\"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/AtlasNacional/Alertas/AlertasCemaden2012-2021.xlsx\")\n\n\n\n\nTabelas\nTabela processada em R e apresentada de maneira estática.\n\n\nCode\nTot_Mun <- planilha %>%\n  mutate(Mun = str_to_upper(`Município`)) %>%\n  group_by(`Código IBGE`, Mun, `Evento`) %>%\n  summarise(Tot_Event = n()) %>%\n  mutate(Evento = ifelse(Evento == \"Geo/Hidro\", \"Hidrogeo\", Evento)) %>%\n  pivot_wider(names_from = Evento, values_from = Tot_Event, values_fill = 0) %>%\n  mutate(tot_geo = Geo + Hidrogeo, tot_hidro = Hidro + Hidrogeo) %>%\n  select(`Código IBGE`, Mun, tot_geo, tot_hidro)\n\nkable(head(Tot_Mun))\n\n\n\n\n\nCódigo IBGE\nMun\ntot_geo\ntot_hidro\n\n\n\n\n1100189\nPIMENTA BUENO\n0\n1\n\n\n1100205\nPORTO VELHO\n4\n9\n\n\n1200104\nBRASILÉIA\n2\n6\n\n\n1200252\nEPITACIOLÂNDIA\n0\n1\n\n\n1200328\nJORDÃO\n0\n1\n\n\n1200401\nRIO BRANCO\n3\n18\n\n\n\n\n\nEssa tabela pode ser apresentada de maneira dinâmica com a biblioteca DT.\n\n\nCode\ndatatable(Tot_Mun)\n\n\n\n\n\n\n\nOu ainda pelo Observable.\n\n\nCode\nojs_define(totais = Tot_Mun)\n\n\n\n\nCode\nviewof tabexemp = Inputs.table(transpose(totais));\n\n\n\n\n\n\n\n\n\nGráficos\nAgregação de dados no R para a produção de gráficos estáticos.\n\n\nCode\nMed_GdReg_data <- planilha %>%\n  mutate(dataref = date_group(as.Date(planilha$Data), \"month\"),\n         mes = factor(date_format(dataref, format = \"%m\"), \n                      labels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")),\n         GdReg = factor(as.numeric(substr(`Código IBGE`, 1, 1)), labels = c(\"N\", \"NE\", \"SE\", \"S\", \"CO\")),\n         geologico = ifelse(Evento %in% c(\"Geo\", \"Geo/Hidro\"), 1, 0),\n         hidrologico = ifelse(Evento %in% c(\"Hidro\", \"Geo/Hidro\"), 1, 0)) %>%\n  group_by(GdReg, mes, dataref) %>%\n  summarise(Tot_Event = n(), Tot_geo = sum(geologico), Tot_hidro = sum(hidrologico)) %>%\n  ungroup() %>%\n  group_by(GdReg, mes) %>%\n  summarise(Media_geo = mean(Tot_geo), Media_hidro = mean(Tot_hidro), Media_Event = mean(Tot_Event)) %>%\n  # manobra esquisita para arrumar a tabela, rever esse código adiante de pivotagem\n  pivot_longer(cols = starts_with(\"Media_\"), names_to = \"Tipo\", values_to = \"Media\") %>%\n  pivot_wider(names_from = c(\"mes\", \"Tipo\"), values_from = Media, values_fill = 0) %>%\n  pivot_longer(cols = !GdReg, names_to = c(\"mes\", \"Tipo\"), names_pattern = \"(.*)_Media_(.*)\", values_to = \"Media\") %>%\n  # até aqui.\n  ungroup() %>%\n  group_by(Tipo, mes) %>%\n  mutate(mes = factor(mes, levels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")))\n\n\nMed_Pais_geral <- Med_GdReg_data %>%\n  group_by(Tipo, mes) %>%\n  summarise(Media = sum(Media)) %>%\n  mutate(GdReg = \"Brasil\") %>%\n  select(GdReg, mes, Tipo, Media)\n\nMed_Geral <- Med_GdReg_data %>%\n  bind_rows(Med_Pais_geral) %>%\n  mutate(GdReg = factor(GdReg, levels = c(\"Brasil\", \"N\", \"NE\", \"SE\", \"S\", \"CO\")))\n\nMed_Geral %>% \n  filter(Tipo == \"Event\") %>%\n  mutate(Media = round(Media, 2)) %>%\n  pivot_wider(id_cols = GdReg, names_from = mes, values_from = Media) %>%\n  datatable()\n\n\n\n\n\n\n\nConfigurações de tema e estilo - desenvolvido pro Atlas Nacional Digital 2022.\n\n\nCode\nshowtext_auto()\nshowtext_opts(dpi = 300)\nfont_add(family = \"univers\", regular = \"C:/Windows/Fonts/univer.TTF\")\n\ntheme_set(\n  theme_igray() + \n    theme(plot.title = element_text(family = \"univers\", face = \"bold\", size = 11, hjust = 0.5, vjust = 0.5, lineheight = 1.1, margin = margin(12, 0, 12, 0)),\n          legend.position = \"bottom\",\n          legend.title = element_blank(),\n          legend.background = element_rect(fill = \"white\"),\n          legend.text = element_text(family = \"univers\", face = \"plain\", size = 9, margin = margin(0, 15, 0, 5)),\n          legend.key.width = unit(1.5, \"cm\"),\n          plot.background = element_rect(fill = \"#d0cece\"),\n          plot.margin = margin(t = 0, r = 40, b = 0, l = 10 ),\n          axis.title = element_text(family = \"univers\", face = \"plain\", size = 9),\n          axis.text = element_text(family = \"univers\", face = \"plain\", size = 7)))\n\ncores <- c(\"#000000\", brewer.pal(5, \"Set1\"))\nnames(cores) <- c(\"Brasil\", levels(Med_GdReg_data$GdReg))\ncolScale <- scale_color_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = cores)\nlineScale <- scale_linetype_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = c(2, 1, 1, 1, 1, 1))\n\n\nAlertas Hidrológicos.\n\n\nCode\ngraf_hidro <- Med_Geral %>%\n  filter(Tipo == \"hidro\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco hidrológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_hidro\n\n\n\n\n\nFigure 1: Hidrológico\n\n\n\n\nAlertas Geológicos.\n\n\nCode\ngraf_geo <- Med_Geral %>%\n  filter(Tipo == \"geo\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco geológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_geo\n\n\n\n\n\nFigure 2: Geológico\n\n\n\n\nAlertas.\n\n\nCode\n# graf_geral <- Med_Geral %>%\n#   filter(Tipo == \"Event\") %>%\n#   arrange(GdReg) %>%\n#   ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n#   geom_line(size = 0.5) +\n#   labs(title = \"Média mensal de alertas de risco geohidrológico,\\npor Grandes Regiões - 2012-2021\") +\n#   xlab(\"Mês\") +\n#   ylab(\"Alertas\") +\n#   lineScale +\n#   colScale +\n#   theme(legend.position=\"none\") +\n#   facet_wrap(vars(GdReg), nrow = 3)\n\ngraf_N <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"N\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Norte\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_NE <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"NE\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Nordeste\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_SE <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"SE\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Sudeste\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_S <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"S\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Sul\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_CO <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"CO\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Centro-Oeste\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_BR <- Med_Geral %>%\n  filter(Tipo == \"Event\" & GdReg == \"Brasil\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Brasil\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  scale_linetype_manual(values = 2) +\n  colScale +\n  theme(legend.position=\"none\")\n\ngraf_N\ngraf_NE\ngraf_SE\ngraf_S\ngraf_CO\ngraf_BR\n\n\n\n\n\n\n\n\n(a) Norte\n\n\n\n\n\n\n\n(b) Nordeste\n\n\n\n\n\n\n\n\n\n(c) Sudeste\n\n\n\n\n\n\n\n(d) Sul\n\n\n\n\n\n\n\n\n\n(e) Centro-Oeste\n\n\n\n\n\n\n\n(f) Brasil\n\n\n\n\nFigure 3: Geral\n\n\n\nAinda vou testar as possibilidades de produção de gráficos interativos.\n\n\nMapas\nprimeiro carrega as bibliotecas do Observable. Foram usadas a bertin para produção de cartogramas e Leaflet para a incorporação de mapas com pan e zoom.\n\n\nCode\nbertin = require(\"bertin@1\");\n\n\n\n\n\n\n\n\n\nCode\nL = require('leaflet@1.7.1');\n\n\n\n\n\n\n\n\n\nCode\nhtml` <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\"\n   integrity=\"sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\"\n   crossorigin=\"\"/>`\n\n\n\n\n\n\n\n\n\nCode\nPlot.plot({\n  x: {\n    label: \"% Pop em risco\"\n  },\n  y: {\n    label: \"Pop abs em risco\"\n  },\n  marks: [\n    Plot.dot(MunicUF.data.features.map((d) => d.properties), {x: d => d[\"morador\"] / d[\"pop2010\"] * 100 , y: \"morador\"}),\n    Plot.dot(MunicUF.data.features.filter((d) => d.properties.nommunic == selNomMunic).map((d) => d.properties), {x: d => d[\"morador\"] / d[\"pop2010\"] * 100, y: \"morador\", fill: \"#ff0000\"})\n  ]\n});\n\n\n\n\n\n\n\n\n\nDá para colocar texto e figuras em margem, etc. Usa o bootstrap para formatar o conteúdo html.\n\n\nCode\nviewof selNomUF = Inputs.select(\n    listaUF.data.features.map((d) => d.properties.nm_uf), \n    {\n        label: \"Unidade da Federação\"\n    }\n);\n\n\n\n\n\n\n\nAs ferramentas de layout são relativamente simples, mas podem ser trabalhadas com mais detalhe utilizando html e css.\n\n\nCode\nmapauf = bertin.draw({\n  params: { background: \"#bde1f0\", margin: 10 },\n  layers: [{\n      type: \"layer\",\n      geojson: selMunic,\n      fill: \"#ff0000\",      \n      fillOpacity: 1,\n      stroke: \"#000000\",\n      strokeWidth: 2,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: MunicUF.data,\n      fill: \"#000000\",\n      fillOpacity: 0.0,\n      stroke: \"#ff0000\",\n      strokeWidth: 3,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: geo_uf.data,\n      fill: \"#999999\",      \n      fillOpacity: 0.25,\n      stroke: \"#777777\",\n      strokeWidth: 3,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"tiles\",\n      opacity: 1,\n      style: \"openstreetmap\",\n    }\n  ]\n});\n\n\n\n\n\n\n\nAs camadas utilizadas são obtidas dos geoserviços do IBGE. Para reduzir a transferência de dados, só são requisitados do servidor os dados necessários para construir as listas e mapa mosca das UFs e Municípios e representar as BATERs do município selecionado, através dos campos PropertyName e cql_filter.\n\n\nCode\nurlWFS = \"https://geoservicos.ibge.gov.br/geoserver/ows\";\n\nlistaUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  PropertyName: \"cd_uf,nm_uf\",\n  outputFormat: \"application/json\"\n});\n\ngeo_uf = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  cql_filter: `nm_uf='${selNomUF}'`,\n  outputFormat: \"application/json\"\n});\n\nMunicUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_Municipios_mapeados\",\n  cql_filter: `uf='${selUF}'`,\n  outputFormat: \"application/json\"\n});\n\nbater = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_BATER_MD\",\n  cql_filter: `geo_mun='${selCdMunic}'`,\n  outputFormat: \"application/json\"\n});\n\nselUF = stripAccents(selNomUF);\n\nselCdMunic = MunicUF.data.features.filter((d) => d.properties.nommunic === selNomMunic)[0].properties.codmunic;\n\nselMunicArray = MunicUF.data.features.filter((d) => d.properties.nommunic == selNomMunic);\n\nselMunic = ({\n  \"type\":\"FeatureCollection\",\n  \"features\":selMunicArray  \n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEssa tabela pode funcionar como seleção do município…\n\n\nCode\nviewof tabMunic = Inputs.table(MunicUF.data.features.map((d) => d.properties));\n\n\n\n\n\n\n\n… ao invés dessa caixinha de seleção.\n\n\nCode\nviewof selNomMunic = Inputs.select(\n    MunicUF.data.features.map((d) => d.properties.nommunic),\n    {\n        label: \"Município\"\n    }\n);\n\n\n\n\n\n\n\n\n\n\nCode\nmapaInterativo = {\n  let container = DOM.element('div', { style: `width:${width*0.95}px;height:${width/1.7}px` });\n \n  yield container;\n  \n  let map = L.map(container);\n  let osmTileLayer = L.tileLayer( 'http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {\n      attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a>'\n  }).addTo( map );\n\n  let limMunic = L.geoJson(selMunic, {\n    weight: 4,\n    color: '#777777'\n  }).addTo(map);\n  \n  let baterLayer = L.geoJson(bater.data, {\n    weight: 5,\n    color: '#ff0000',\n    onEachFeature: function (feature, layer) {\n      let popupTxt = 'Moradores: ' + \n      feature.properties.d004 +\n      '<br>Domicílios: ' + feature.properties.d001 +\n      '<br>Acurácia: ' + feature.properties.acuracia;\n      layer.bindPopup(popupTxt);\n    }\n  }).addTo(map);\n  map.fitBounds(baterLayer.getBounds());\n}"
  },
  {
    "objectID": "index.html#apêndice",
    "href": "index.html#apêndice",
    "title": "Avaliação preliminar de funcionalidades do sistema Quarto para publicação de estatísticas da população em área de risco.",
    "section": "Apêndice",
    "text": "Apêndice\nFunções do Observable utilizadas no código anterior. Devido à natureza reativa do Observable, a ordem dos códigos do mesmo no documento não tem importância.\n\n\nCode\nasync function wfsRequest(\n  url,\n  operation = \"GetCapabilities\",\n  extraParameters = {}\n) {\n  const queryParameters = new URLSearchParams({\n    request: operation,\n    service: \"WFS\",\n    ...extraParameters\n  }).toString();\n\n  console.log(queryParameters);\n\n  const response = await fetch(`${url}?${queryParameters}`);\n  const responseFormat = response.headers.get(\"Content-Type\");\n\n  // If the WFS server returns Content-Type header containing \"json\" it will read the data as json, otherwise as text.\n  const data = responseFormat.includes(\"json\")\n    ? await response.json()\n    : await response.text();\n\n  return {\n    data: data,\n    status: response.status\n  };\n};\n\nfunction stripAccents(str) {\n    var reAccents = /[àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ]/g;\n    var replacements = 'aaaaaceeeeiiiinooooouuuuyyAAAAACEEEEIIIINOOOOOUUUUY';\n    return str.replace(reAccents, function (match) {\n        return replacements[reAccents.source.indexOf(match)];\n    });\n};"
  }
]
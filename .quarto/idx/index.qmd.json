{"title":"Avaliação preliminar de funcionalidades do sistema [*Quarto*](https://quarto.org/) para publicação de estatísticas da população em área de risco.","markdown":{"yaml":{"title":"Avaliação preliminar de funcionalidades do sistema [*Quarto*](https://quarto.org/) para publicação de estatísticas da população em área de risco.","author":"Joaquim","date":"01/10/2022","format":{"html":{"code-fold":true,"fig-height":5,"fig-width":7,"page-layout":"full"}},"execute":{"warning":false,"cache":true,"freeze":true}},"headingText":"Introdução","containsRefs":false,"markdown":"\n\n[*Quarto*](https://quarto.org/) é um sistema de produção de publicações técnicas e científicas que incorpora ferramentas de formatação de texto com códigos de programação para produção de gráficos e tabelas. É o sucessor do [*R markdown*](https://rmarkdown.rstudio.com/) e segue a linha de outros *notebooks* reativos, como o [*Jupyter Notebook*](https://jupyter.org/). É um sistema de código aberto cujos principais destques são permitir a utilização de diversas linguagens de programação ([*Python*](https://www.python.org/), [*R*](https://www.r-project.org/), [*Julia*](https://julialang.org/) e [*Observable*](https://observablehq.com/)) e a exportação para diversos formatos de publicação através da utilização do [*Pandoc*](https://pandoc.org/).\n\nAs suas funcionalidades relativas ao processamento de dados espaciais e tabulares com linguagens de programação e produção de documentos em .pdf ou .doc já são interessantes por facilitar a padronização da análise e publicação de resultados. Mas são sua integração com o *Observable* e capacidade de produção de documentos *html* que oferecem as maiores possibilidades de enriquecimento da publicação com conteúdo dinâmico e interativo.\n\nElementos interativos como listas de seleção, tabelas, e gráficos, etc, produzidos nas linguagens *Python*, *R* ou *Julia* possuem recursos limitados de interatividade em publicações *online*, necessitando de *frameworks* como o [*Dash*](https://dash.plotly.com/) ou o [*Shiny*](https://shiny.rstudio.com/) para poderem apresentar comportamento realmente dinâmico. Esses *frameworks* exigem a configuração do servidor de hospedagem com os interpretadores e bibliotecas e também de tempo de processamento para atender requisições dos usuários, dificultando a utilização dessas capacidades na publicação de resultados de pesquisas. O *Observable*, porém, é um *JavaScript melhorado* que é interpretado diretamente pelo navegador do usuário, dispensando a utilização do servidor no processamento dos dados. Essa característica, associada à utilização de [geoserviços do IBGE](https://geoservicos.ibge.gov.br), permite desde a publicação enriquecida com conteúdo interativo até a produção de *dashboards* complexos com dados de diversas fontes sem a necessidade de gastos com servidor e apoio institucional.\n\n## Exemplos de funcionalidades\n\nPara avaliar algumas funcionalidades de maior relevância, foram utilizados os dados de Alertas de riscos de desastres emitidos pelo CEMADEN compilados para o Atlas Nacional Digital do Brasil - 2022.\n\n### Dados e Bibliotecas\nCarrega a tabela com os dados e as bibliotecas utilizadas.\n\n```{r}\n#| warning: false\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(writexl)\nlibrary(sf)\nlibrary(DT)\nlibrary(clock)\nlibrary(ggthemes)\nlibrary(showtext)\nlibrary(RColorBrewer)\nlibrary(knitr)\n\nplanilha <- read_excel(\"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/AtlasNacional/Alertas/AlertasCemaden2012-2021.xlsx\")\n\n```\n\n### Tabelas\nTabela processada em *R* e apresentada de maneira estática.\n```{r}\n#| warning: false\n\nTot_Mun <- planilha %>%\n  mutate(Mun = str_to_upper(`Município`)) %>%\n  group_by(`Código IBGE`, Mun, `Evento`) %>%\n  summarise(Tot_Event = n()) %>%\n  mutate(Evento = ifelse(Evento == \"Geo/Hidro\", \"Hidrogeo\", Evento)) %>%\n  pivot_wider(names_from = Evento, values_from = Tot_Event, values_fill = 0) %>%\n  mutate(tot_geo = Geo + Hidrogeo, tot_hidro = Hidro + Hidrogeo) %>%\n  select(`Código IBGE`, Mun, tot_geo, tot_hidro)\n\nkable(head(Tot_Mun))\n```\nEssa tabela pode ser apresentada de maneira dinâmica com a biblioteca [*DT*](https://rstudio.github.io/DT/).\n```{r}\n#| warning: false\ndatatable(Tot_Mun)\n\n```\nOu ainda pelo *Observable*.\n```{r}\n#| cache: false\nojs_define(totais = Tot_Mun)\n```\n```{ojs}\nviewof tabexemp = Inputs.table(transpose(totais));\n\n```\n### Gráficos\nAgregação de dados no *R* para a produção de gráficos estáticos.\n```{r}\n\nMed_GdReg_data <- planilha %>%\n  mutate(dataref = date_group(as.Date(planilha$Data), \"month\"),\n         mes = factor(date_format(dataref, format = \"%m\"), \n                      labels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")),\n         GdReg = factor(as.numeric(substr(`Código IBGE`, 1, 1)), labels = c(\"N\", \"NE\", \"SE\", \"S\", \"CO\")),\n         geologico = ifelse(Evento %in% c(\"Geo\", \"Geo/Hidro\"), 1, 0),\n         hidrologico = ifelse(Evento %in% c(\"Hidro\", \"Geo/Hidro\"), 1, 0)) %>%\n  group_by(GdReg, mes, dataref) %>%\n  summarise(Tot_Event = n(), Tot_geo = sum(geologico), Tot_hidro = sum(hidrologico)) %>%\n  ungroup() %>%\n  group_by(GdReg, mes) %>%\n  summarise(Media_geo = mean(Tot_geo), Media_hidro = mean(Tot_hidro), Media_Event = mean(Tot_Event)) %>%\n  # manobra esquisita para arrumar a tabela, rever esse código adiante de pivotagem\n  pivot_longer(cols = starts_with(\"Media_\"), names_to = \"Tipo\", values_to = \"Media\") %>%\n  pivot_wider(names_from = c(\"mes\", \"Tipo\"), values_from = Media, values_fill = 0) %>%\n  pivot_longer(cols = !GdReg, names_to = c(\"mes\", \"Tipo\"), names_pattern = \"(.*)_Media_(.*)\", values_to = \"Media\") %>%\n  # até aqui.\n  ungroup() %>%\n  group_by(Tipo, mes) %>%\n  mutate(mes = factor(mes, levels = c(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")))\n\n\nMed_Pais_geral <- Med_GdReg_data %>%\n  group_by(Tipo, mes) %>%\n  summarise(Media = sum(Media)) %>%\n  mutate(GdReg = \"Brasil\") %>%\n  select(GdReg, mes, Tipo, Media)\n\nMed_Geral <- Med_GdReg_data %>%\n  bind_rows(Med_Pais_geral) %>%\n  mutate(GdReg = factor(GdReg, levels = c(\"Brasil\", \"N\", \"NE\", \"SE\", \"S\", \"CO\")))\n\nMed_Geral %>% \n  filter(Tipo == \"Event\") %>%\n  mutate(Media = round(Media, 2)) %>%\n  pivot_wider(id_cols = GdReg, names_from = mes, values_from = Media) %>%\n  datatable()\n```\nConfigurações de tema e estilo - desenvolvido pro Atlas Nacional Digital 2022.\n```{r}\n\nshowtext_auto()\nshowtext_opts(dpi = 300)\nfont_add(family = \"univers\", regular = \"C:/Windows/Fonts/univer.TTF\")\n\ntheme_set(\n  theme_igray() + \n    theme(plot.title = element_text(family = \"univers\", face = \"bold\", size = 11, hjust = 0.5, vjust = 0.5, lineheight = 1.1, margin = margin(12, 0, 12, 0)),\n          legend.position = \"bottom\",\n          legend.title = element_blank(),\n          legend.background = element_rect(fill = \"white\"),\n          legend.text = element_text(family = \"univers\", face = \"plain\", size = 9, margin = margin(0, 15, 0, 5)),\n          legend.key.width = unit(1.5, \"cm\"),\n          plot.background = element_rect(fill = \"#d0cece\"),\n          plot.margin = margin(t = 0, r = 40, b = 0, l = 10 ),\n          axis.title = element_text(family = \"univers\", face = \"plain\", size = 9),\n          axis.text = element_text(family = \"univers\", face = \"plain\", size = 7)))\n\ncores <- c(\"#000000\", brewer.pal(5, \"Set1\"))\nnames(cores) <- c(\"Brasil\", levels(Med_GdReg_data$GdReg))\ncolScale <- scale_color_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = cores)\nlineScale <- scale_linetype_manual(name = \"GdReg\", labels = c(\"Brasil\", \"Norte\", \"Nordeste\", \"Sudeste\", \"Sul\", \"Centro-Oeste\"), values = c(2, 1, 1, 1, 1, 1))\n\n```\nAlertas Hidrológicos.\n```{r}\n#| label: fig-hidro\n#| fig-cap: Hidrológico\n\n\ngraf_hidro <- Med_Geral %>%\n  filter(Tipo == \"hidro\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco hidrológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_hidro\n```\nAlertas Geológicos.\n```{r}\n#| label: fig-geo\n#| fig-cap: Geológico\n\n\ngraf_geo <- Med_Geral %>%\n  filter(Tipo == \"geo\") %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(stat = \"identity\", position = \"identity\", size = 0.8, ) +\n  labs(title = \"Média mensal de alertas de risco geológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40))\n\ngraf_geo\n```\nAlertas.\n```{r}\n#| label: fig-geral\n#| fig-cap: Geral\n#| fig-column: screen\n#| fig-width : 15\n\n\ngraf_geral <- Med_Geral %>%\n  filter(Tipo == \"Event\") %>%\n  arrange(GdReg) %>%\n  ggplot(aes(x = mes, y = Media, colour = GdReg, group = GdReg, linetype = GdReg)) +\n  geom_line(size = 0.5) +\n  labs(title = \"Média mensal de alertas de risco geohidrológico,\\npor Grandes Regiões - 2012-2021\") +\n  xlab(\"Mês\") +\n  ylab(\"Alertas\") +\n  lineScale +\n  colScale +\n  theme(legend.margin = margin(0, 40, 0, 40)) +\n  facet_wrap(vars(GdReg), nrow = 1)\n\ngraf_geral\n```\nAinda vou testar as possibilidades de produção de gráficos interativos.\n\n### Mapas\nprimeiro carrega as bibliotecas do *Observable*. Foram usadas a [*bertin*](https://github.com/neocarto/bertin) para produção de cartogramas e [*Leaflet*](https://leafletjs.com/) para a incorporação de mapas com *pan* e *zoom*.\n```{ojs}\n\nbertin = require(\"bertin@1\");\n```\n```{ojs}\nL = require('leaflet@1.7.1');\n```\n```{ojs}\nhtml` <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\"\n   integrity=\"sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\"\n   crossorigin=\"\"/>`\n```\n\nAs camadas utilizadas são obtidas dos geoserviços do IBGE. Para reduzir a transferência de dados, só são requisitados do servidor os dados necessários para construir as listas e mapa mosca das UFs e Municípios e representar as BATERs do município selecionado, através dos campos *PropertyName* e *cql_filter*.\n\n```{ojs}\n\nurlWFS = \"https://geoservicos.ibge.gov.br/geoserver/ows\";\n\nlistaUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  PropertyName: \"cd_uf,nm_uf\",\n  outputFormat: \"application/json\"\n});\n\ngeo_uf = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGMAT:pbqg22_02_Estado_NomUF\",\n  cql_filter: `nm_uf='${selNomUF}'`,\n  outputFormat: \"application/json\"\n});\n\nMunicUF = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_Municipios_mapeados\",\n  cql_filter: `uf='${selUF}'`,\n  outputFormat: \"application/json\"\n});\n\nbater = await wfsRequest(urlWFS, \"GetFeature\", {\n  service: \"WFS\",\n  version: \"2.0.0\",\n  typeNames: \"CGEO:PARBR2018_BATER_MD\",\n  cql_filter: `geo_mun='${selCdMunic}'`,\n  outputFormat: \"application/json\"\n});\n\nselUF = stripAccents(selNomUF);\n\nselCdMunic = MunicUF.data.features.filter((d) => d.properties.nommunic === selNomMunic)[0].properties.codmunic;\n\nselMunicArray = MunicUF.data.features.filter((d) => d.properties.nommunic == selNomMunic);\n\nselMunic = ({\n  \"type\":\"FeatureCollection\",\n  \"features\":selMunicArray  \n});\n\n\n```\n\n\n\n```{ojs}\n//| column: margin\n\nviewof selNomUF = Inputs.select(\n    listaUF.data.features.map((d) => d.properties.nm_uf), \n    {\n        label: \"Unidade da Federação\"\n    }\n);\n```\n\n\n\n```{ojs}\n//| column: margin\nmapauf = bertin.draw({\n  params: { background: \"#bde1f0\", margin: 10 },\n  layers: [{\n      type: \"layer\",\n      geojson: selMunic,\n      fill: \"#ff0000\",      \n      fillOpacity: 1,\n      stroke: \"#000000\",\n      strokeWidth: 2,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: MunicUF.data,\n      fill: \"#000000\",\n      fillOpacity: 0.0,\n      stroke: \"#ff0000\",\n      strokeWidth: 3,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"layer\",\n      geojson: geo_uf.data,\n      fill: \"#999999\",      \n      fillOpacity: 0.25,\n      stroke: \"#777777\",\n      strokeWidth: 3,\n      symbol: \"square\",\n      symbol_size: 50\n    },\n    {\n      type: \"tiles\",\n      opacity: 1,\n      style: \"openstreetmap\",\n    }\n  ]\n});\n```\n\n\n\n```{ojs}\nviewof selNomMunic = Inputs.select(\n    MunicUF.data.features.map((d) => d.properties.nommunic),\n    {\n        label: \"Município\"\n    }\n)\n```\n:::{.column-screen-inset}\n\n```{ojs}\n\nmapaInterativo = {\n  let container = DOM.element('div', { style: `width:${width*0.95}px;height:${width/1.7}px` });\n \n  yield container;\n  \n  let map = L.map(container);\n  let osmTileLayer = L.tileLayer( 'http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {\n      attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a>'\n  }).addTo( map );\n  \n  let baterLayer = L.geoJson(bater.data, {\n    weight: 5,\n    color: '#ff0000'\n  }).addTo(map);\n  baterLayer.bindPopup(\"Aqui aparecem os dados da bater\");\n  map.fitBounds(baterLayer.getBounds());\n}\n\n\n\n```\n:::\n## Apêndice\nFunções do *Observable* utilizadas no código anterior. Devido à natureza reativa do *Observable*, a ordem dos códigos do mesmo no documento não tem importância.\n\n```{ojs}\n\nasync function wfsRequest(\n  url,\n  operation = \"GetCapabilities\",\n  extraParameters = {}\n) {\n  const queryParameters = new URLSearchParams({\n    request: operation,\n    service: \"WFS\",\n    ...extraParameters\n  }).toString();\n\n  console.log(queryParameters);\n\n  const response = await fetch(`${url}?${queryParameters}`);\n  const responseFormat = response.headers.get(\"Content-Type\");\n\n  // If the WFS server returns Content-Type header containing \"json\" it will read the data as json, otherwise as text.\n  const data = responseFormat.includes(\"json\")\n    ? await response.json()\n    : await response.text();\n\n  return {\n    data: data,\n    status: response.status\n  };\n};\n\nfunction stripAccents(str) {\n    var reAccents = /[àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ]/g;\n    var replacements = 'aaaaaceeeeiiiinooooouuuuyyAAAAACEEEEIIIINOOOOOUUUUY';\n    return str.replace(reAccents, function (match) {\n        return replacements[reAccents.source.indexOf(match)];\n    });\n};\n\n```"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","theme":"cosmo","title":"Avaliação preliminar de funcionalidades do sistema [*Quarto*](https://quarto.org/) para publicação de estatísticas da população em área de risco.","author":"Joaquim","date":"01/10/2022","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}